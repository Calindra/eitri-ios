# SimpleNativeEitri

A comprehensive example demonstrating how to integrate Eitri framework into a native iOS application. This project serves as a reference implementation for developers looking to embed Eitri apps within their existing native iOS applications.

## Project Overview

SimpleNativeEitri is a minimal iOS application that showcases the integration of the Eitri framework. The application features a single button that launches the "eitri-doctor" app, which is a diagnostic tool provided by the Eitri framework to validate and troubleshoot Eitri setups.

### Key Components

- **ViewController**: The main entry point featuring a simple UI with an Eitri launch button
- **AppDelegate**: Handles Eitri framework initialization during app startup
- **EitriService**: Core service managing EitriMachine configuration and lifecycle
- **EitriBridgeHelper**: Utility class for exposing native APIs to Eitri apps
- **MainAppService**: Singleton example service managing the EitriService instance

### Setup Instructions

1. Clone this repository
2. Open the project in Xcode
3. Build and run the application

## Post Install & Integration Guide

After successfully integrating the eitri-ios SDK into your project, you may want to consider implementing additional features to enhance your app's capabilities.

The following sections outline optional integrations and features that can be implemented based on your specific requirements.

### Environment Key Management for Different Build Types

Environment keys for production and non-production environments will be provided separately. Builds must select the appropriate key when invoking the Eitri machine configuration:

### Development Environment Integration for Eitri Apps

For development builds only, implement an integrated development environment that allows developers to test their Eitri apps directly within the native application:

#### Development Button Implementation

Add a dedicated Eitri development button that provides two alternatives:

1. **Manual Workspace Input**: Allow developers to input a workspace ID manually
2. **QR Code Scanner**: Scan QR codes generated by the Eitri CLI

```swift
// Example implementation
let developmentButton = UIButton(type: .system)
developmentButton.setTitle("Eitri Development", for: .normal)
developmentButton.addTarget(self, action: #selector(showDevelopmentOptions), for: .touchUpInside)

@objc func showDevelopmentOptions() {
    // Show interface with input field or QR scanner
}

func openWorkspace(workspaceId: String) {
    let eitriService = MainAppService.shared.eitriService
    eitriService.runOnTop(RunInput(
        workspaceId: workspaceId, // e.g., "4321-4321-4321-4321-4312"
        //...
    ))
}
```

#### Integration Benefits

Once captured and interpreted, a workspace ID can be used with the Eitri machine run command, opening the developer's workspace within the app and providing access to exclusive exposed app APIs.

### Exposed APIs for Enhanced Eitri App Context

The `EitriBridgeHelper` class contains illustrative methods for exposing native capabilities to Eitri apps, allowing them to extend their functionality beyond their traditional sandbox:

```swift
// Example from EitriBridgeHelper.swift
func exposeFunctions(eitriMachine: EitriMachine) {
    // Simple math API example
    try? eitriMachine.bridge.exposeMethod(namespace: "math", methodName: "sum", fn: { params in
        if let a = params.data["a"] as? Double, let b = params.data["b"] as? Double {
            return a + b
        }
        throw NSError(domain: "math.sum.failed", code: 0)
    })
    
    // Additional APIs can be exposed here
    // Examples: session data sharing, device capabilities, etc.
}
```

#### Common Use Cases

- **Session Data Sharing**: Share client session information with Eitri apps
- **Device Capabilities**: Expose camera or other device features
- **Data Persistence**: Allow Eitri apps to store data in the native app's database

### Complete CLI Integration

The Eitri CLI generates QR codes and launches deeplinks following the pattern `eitri://workspace/${workspaceId}`. The CLI can also be configured to generate deeplinks using the app's specific protocol:

```
Configuration example: app://workspace/${workspaceId}
```

This system enables the app to:
- Respond to deeplinks generated by the CLI
- Scan deeplinks using the device's standard camera
- Automatically launch appropriate Eitri apps based on the workspace ID

### Deeplink Integration

Implement deeplink handling to interpret links that reach flows created with Eitri apps

#### Individual Deeplink Handling

You can create deeplink handlers to open dedicated eitri-apps using eitri-machine run method.

#### Dedicated Protocol for Eitri Apps

You can also implement a dedicated protocol for opening Eitri apps. Eg:

```
${yourapp}://run/${slug}/?${paramsInQueryString}
```

Example: `yourapp://run/customer-support/?userId=123&sessionId=abc`

The app can interpret these deeplinks and construct the run command dynamically, passing all values as parameters to the Eitri machine.

### Push Notification Integration

Push notification integration should preferably reuse the protocols created for deeplink integration. This approach ensures consistency and reduces complexity:

```swift
// Example push notification payload
{
    "type": "eitri_launch",
    "deeplink": "yourapp://run/notification-handler/?notificationId=456&type=urgent"
}
```

When a push notification is received, extract the deeplink and process it using the same deeplink handling mechanism implemented for direct deeplink integration.

## Development Notes

### Configuration Points

- **Debug Mode**: Configure `isEitriDevEnabled()` based on build type (EitriService.swift:67-70)

## Security Considerations

- Debug mode should be disabled in production builds
- Deeplink handling should include proper validation and sanitization
- Preferably, workspace running and eitri-app development should only be done in development builds
